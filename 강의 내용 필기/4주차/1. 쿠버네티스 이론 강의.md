---
sticker: emoji//270d-fe0f
tags:
  - 쿠버네티스
  - k8s
---
# 개념 트리
```bash
📌 Kubernetes (클러스터)
├── 1️⃣ 클러스터 구성 요소
│   ├── 마스터 노드 (Control Plane)
│   │   ├── kube-apiserver (API 서버)
│   │   ├── kube-scheduler (스케줄러)
│   │   ├── kube-controller-manager (컨트롤러 매니저)
│   │   ├── etcd (클러스터 저장소)
│   │   ├── kube-proxy (네트워크 라우팅 & 로드밸런싱)
│   │   ├── CoreDNS (내부 DNS)
│   │   ├── Calico / Flannel (네트워크 정책 & Overlay)
│   │   ├── Metrics Server (메트릭 수집)
│   │   └── Kubernetes Dashboard (웹 UI)
│   ├── 워커 노드 (Worker Node)
│   │   ├── kubelet (Pod 관리 에이전트)
│   │   ├── 컨테이너 런타임 (Docker, containerd)
│   │   └── Pod (컨테이너 실행 단위)
│   ├── 네트워크 구성
│   │   ├── Service (서비스 - 트래픽 라우팅)
│   │   │   ├── ClusterIP (내부 트래픽 전용)
│   │   │   ├── NodePort (외부에서 특정 노드 포트로 접근)
│   │   │   ├── LoadBalancer (클라우드 로드밸런서)
│   │   │   └── ExternalName (내부 → 외부 도메인 매핑)
│   │   ├── Ingress (HTTP/HTTPS 트래픽 라우팅)
│   │   │   ├── SSL/TLS 암호화 지원
│   │   │   ├── 여러 도메인 라우팅
│   │   │   └── Session Affinity 지원
│   │   └── 네트워크 정책
│   │       ├── Flannel (기본적인 네트워크 오버레이)
│   │       └── Calico (네트워크 정책 & 보안 제어)
├── 2️⃣ 쿠버네티스 오브젝트 (Objects)
│   ├── Workload (애플리케이션 실행 단위)
│   │   ├── Container (컨테이너)
│   │   └── Pod (최소 실행 단위, 하나 이상의 컨테이너 포함)
│   ├── Controller (컨트롤러 - Pod를 자동 관리)
│   │   ├── Deployment (웹 서버, API 서버 등 무중단 배포)
│   │   │   ├── ReplicaSet (파드 개수 조절)
│   │   │   ├── Rollout (배포 & 롤백)
│   │   │   ├── Recreate (기존 Pod 종료 후 배포)
│   │   │   └── RollingUpdate (점진적 업데이트, 무중단 배포)
│   │   ├── StatefulSet (데이터 저장이 필요한 애플리케이션 - DB 등)
│   │   ├── DaemonSet (모든 노드에서 동일한 Pod 실행 - 로그 수집, 모니터링)
│   │   ├── Job (일회성 배치 작업)
│   │   └── CronJob (주기적으로 실행되는 Job - Crontab 방식)
│   ├── Storage (데이터 저장)
│   │   ├── Volume (Pod 내 임시 저장소)
│   │   ├── Persistent Volume (영구 저장소)
│   │   ├── ConfigMap (환경설정 관리)
│   │   └── Secret (보안 데이터 저장 - 패스워드, API 키)
│   ├── Pod의 헬스 체크 (Probe)
│   │   ├── Liveness Probe (컨테이너가 살아있는지 확인 → 실패 시 재시작)
│   │   └── Readiness Probe (컨테이너가 트래픽 받을 준비가 되었는지 확인)
│   └── 배포 전략
│       ├── Recreate (기존 Pod 종료 후 새로운 Pod 배포)
│       └── Rolling Update (점진적으로 배포 → 무중단)
└── 3️⃣ 사이드카 패턴 (Sidecar Pattern)
    ├── 메인 컨테이너 + 보조 컨테이너 (하나의 Pod 내부)
    └── 로그 수집, 데이터 동기화 등
```
# 쿠버네티스

- **클러스터**: 여러 개의 노드로 구성된 컨테이너 오케스트레이션 시스템
	- 마스터 노드: 클러스터를 관리하고 스케줄링 하는 노드
	- 워크 노드: 실제로 어플리케이션이 실행되는 노드
	- 쿠버네티스 컴포넌트: API 서버, 컨트롤러, 스케줄러 등

## 1. K8s 클러스터를 구성하는 "코어 프로세스"
: 코어 프로세스이자 컨테이너
`kubectl`: 커맨드라인 인터페이스(CLI)로, 쿠버네티스 클러스터를 조작하기 위한 도구 (OpenLens 라는 GUI도 있음)
`kube-apiserver`: 클러스터의 모든 요청을 처리하는 중앙  API 게이트웨이로, 클라이언트로부터 오는 REET 요청을 검증하고, API 오브젝트를 구성하고 상태를 보고함
`kube-scheduler`: 쿠버네티스의 기본 스케줄러로, Pod를 실행 가능한 노드를 찾은 다음, 점수를 계산하여 가장 점수가 높은 노드를 선택함
`kube-control`: 쿠버네티스 클러스터에서 실행되는 여러 개의 컨트롤러를 통합 관리하는 프로세스
`etcd`: 쿠버네티스 클러스터의 모든 관리 데이터가 저장되는 곳
`kube-proxy`: 네트워크 라우팅 및 로드밸런싱을 담당하는 프록시(Pod 간의 트래픽 라우팅)
`kubelet`: 각 노드에서 실행되는 에이전트 프로세스로, 해당 노드에서 실행되는 파드와 컨테이너를 관리한다.(파드와 컨테이너 실행, 프로브 실행 등)
`coredns`: Pod가 Service 이름으로부터 IP 주소를 얻기 위해 사용되는 dns
`kube-flannel`: 여러 노드 사이에서 IPv4 네트워크를 제공(모든 노드에서 실행). 이를 통해 Pod 들은 다른 노드들과 IP 주소를 바탕으로 통신 가능.
`calico-kube-controllers`: calico를 위한 컬트롤러. 데이터 스토어로서 etcd를 이용하기 위해서 사용됨.
`calico-node`: 노드 간의 Pod의 통신, 라우팅, 네트워크 전급 관리 기능을 제공(모든 노드에서 실행)
`kubernetes-dashboard`: Web 대시보드
~~`heapster`: kebelet에 내장된 cAdvisor로부터 메트릭 정보를 수집~~(지원중단)
`metrics-server`: heapster를 대신하여, API의 aggregation layer를 통해서 K8s 클러스터 전체로부터 메트릭을 수집함 

## 2. 쿠버네티스 오브젝트
: K8s 클러스터 내부의 엔티티로 Pod, Controlle, Serveice 등의 인스턴스를 의미
- K8s API의 리소스 종류(kind)에 맞게 설정 및 생성
- 생성된 오브젝트는 지정된 상태가 유지되도록 K8s에 의해 제어 된다.
- 같은 네임스페이스 안에서는 동일한 종류(kind)의 이름은 중복될 수 없다.
- K8s 시스템 관련 기능을 수행하는 오브젝트는 kub3-system 네임스페이스에 만들어 진다.
```markdown
💡**쿠버네티스 API**
-> 쿠버네티스의 조작은 모두 API로 동작함
-> API는 CLI kubectl을 통해 마스터 노드 kube-apiserver에게 YAML 혹은 JSON 형식으로 전송함
```

### Workload
: Container, Pod, Contoller가 이루는 그룹을 의미 (컨테이너 실행을 관리하기 위해 사용)

### Container
: 쿠버네티스에서 어플리케이션이 실행되는 가장 작은 단위로, Pod 내부에서 실행되는 실행 환경(단독으로 실행 불가능 X)
- Docker와 비슷하게, 컨테이너 가동 시 이미지, 실행 명령어, 실행 인자, 환경 변수, 리소스 요청/상한 값 설정이 되야함.

### Pod
: 컨테이너를 실행하기 위한 오브젝트로, 하나 이상의 컨테이너를 포함
- 같은 파트 안의 컨테이너들은 *같은 네트워크 네임스페이스*와 *볼륨*을 공유
- 동일한 파드 내부의 컨테이너들은 파드 IP를 공유하여 통신이 가능
	- 같은 IP와 네트워크 네임스페이스를 공유하므로 서로 localhost로 접근 가능
	- 파드 안에서 컨테이너는 포트를 통해 구분함
- 같은 파드 내부의 컨테이너들은 공유 볼륨(Shared Volume)을 마운트 할 수 있음
	- 따라서 서로 데이터 공유가 가능
- 파드와 컨테이너는 일시적 존재
	- 컨테이너는 시작하면 이미지의 초기 상태임
	- 파드의 IP는 DHCP에 의해 기동 시 부여되고 삭제 시 회수됨
	- 그래서 파드에 요청을 보낼 때는 반드시 **Service**를 사용해야 됨
	- 그래서 컨트롤러, 퍼시스턴트 볼륨(영구볼륨), config map, 시크립 등의 오브젝트를 함께 사용해야 됨
`Manifest`: 쿠버네티스 리소스를 정의하는 설정 파일(파D드 등을 생성할 때 사용)

#### 설정(Configutation)
: 어플리케이션이 원하는 동작하도록 환경을 정의하는 것을 말한다.
- 컨테이너 내 설정값 비밀번호 등의 정보는 배포된 네임스페이스로 취득하는 것이 좋음
	*네임스페이스: 하나의 클러스터 내에서 리소스를 논리적으로 구분하는 공간*
#### 서비스(Service)
: 클러스터 내 Pod 간 또는 외부에서 Pod로의 트래픽을 안정적으로 연결하는 네트워크 엔드포인트
- 서비스가 대표 IP를 취득하여 내부 DNS(`coredns`)에 등록
- 클라이언트로부터의 요청 트래픽을 대표 IP로 부하분산하여 전송해주는 역할을 수행
#### 스토리지(Storage)
: 컨테이너의 데이터 유지를 위한 볼륨 및 영구 저장소
- Pod나 Container는 실행 시에만 일시적으로 존재하므로(휘발성), 데이터를 별도 스토리지에 저장함
- **Persistant Volunm**을 사용해 데이터를 영구 저장
- Persistant Volunm은 K8s 범위에 포함되지 않으므로 *외부 스토리지*를 이용

### Controller
: K8s에서 오브젝트의 원하는 상태(Desired State)와 실제 상태를 자동으로 일치시키는 역할을 하는 컴포넌트
- 파드를 자동으로 관리하는 역할

##### `kubectl get pod` 명령어
![Pasted image 20250217222157](images/Pasted%20image%2020250217222157.png)

## 3. 클러스터 네트워크
: Pod 간 통신을 가능하게 하는 네트워크 구조
- ﻿﻿서비스의 IP주소나 포트번호를 외부에서 접속하려면 NodePort 혹은 Loadbalcer를 이용해야 됨
- **Flannel**
	- ﻿﻿간단한 L3 네트워크를 노드간에 구축/서브넷을 구성해서 통신할 수 있도록 설정
	- ﻿﻿Flannel 파드는 *데몬셋 컨트롤러*에 의해 배포 새로운 노드가 추가 되면 자동으로 확장
	- ﻿﻿Flannel은 네트워크 기능만 갖추고 접근제어 기능(정책)은 제공하지 않음
- **Calico**
	- ﻿﻿노드 간 파드 통신에 네트워크 접근 제어(정책) 기능을 추가 제공
	- ﻿﻿2개의 네임스페이스 간 통신을 금지하는 접근 제어 기능(정책)을 설정 가능

### 서비스(Service)
- 앞에서 Pod의 IP 주소는 기동될 때마다 변한다했음. 그래서 서비스의 대표 IP로 접속해야됨.(서비스가 있어야 외부 접속이 가능)
- 동작 순서
	- 로드밸런서의 역할을 하므로, 클라이언트의 요청을 받기 위해 대표 IP 주소 흭득
	- **서비스의 이름**이 내부 DNS(`coredns`)에 등록되어 클라이언트는 서비스 이름으로 IP 흭득 가능
	- 서비스는 클라이언트의 요청을 셀렉터(**selector**)에 지정된 라벨(**label**)과 일치하는 파드 중 하나로 전달
		- `Selector`: 특정 라벨을 가진 리소스를 선택하는 필터링 조건
			- 서비스나 디플로이먼트 등이 특정 파드를 선택할 때 사용
		- `Label`: 쿠버네티스 리소스(Pod, Service 등)에 붙이는 키-값(Key-Value) 형식의 메타데이터(말 그대로 리소스를 라벨링 하는 것)
	- 서비스 생성 후에 만들어진 컨테이너는 자동으로 서비스 환경 변수가 등록됨
		- 파드의 모든 컨테이너는 서비스에 대한 환경 변수가 들어있어야 됨(서비스의 IP주소나 포트 번호 등)
	- 4종류의 Type 존재
		1) `ClusterIP`(기본값): 클러스터 내부에서만 접근 가능할 때 사용
			- **Headless**(ClusterIP가 없는 설정)로 지정한 경우, *Pod의 IP주소*를 내부 DNS에 직접 설정
		2) `NodePort`: 클러스터 외부에서 각 노드의 특정 포트를 통해 접근할 때 사용
			- coredns를 통해 서비스명->클러스터 ip, 외부 도메인이 클러스터 ip->외부 도메인
		3) `LoadBalancer`: 외부에서 클러스터 내부의 서비스로 접근할 때 사용
			- 클라우드 환경에서 외부 로드 밸런서를 생성하여 서비스에 접근할 때 사용(*클러스터 바깥에서 내부로 트래픽을 전달하는게 목적*)
			- 서비스가 자동으로 적절한 파드로 트래픽을 전달함
			- 예전에는 `kube-proxy`가 요청을 처리했지만, 현재는 `iptables` 또는 `ipvs`를 사용하여 성능을 개선하고 라우팅 처리함
		4) `ExternalName`: 클러스터 내부에서 특정 서비스명을 외부 도메인으로 매핑할 때 사용
			- coredns를 통해 서비스명 -> 클러스터 ip, 외부 도메인이 클러스터 ip -> Ingress 또는 loadbrance 진입점으로 변환
- DNS Resolution
	- DNS를 통해 클라이언트가 서비스 이름으로 통신할 가능하게 된걸 말함
- Affinity(어피니티)
	- 클라이언트의 요청을 특정 파드(Pod)로 고정할지 여부를 결정하는 정책
	- **Session Affinity** 또는 **Ingress Sticky Session**으로, 로드 밸런싱 과정에서 세션이 없는 곳으로 요청이 가지 않도록 조정하는 정책(로그인 등에서 사용)

![Pasted image 20250217131450](images/Pasted%20image%2020250217131450.png)

# 4. Controller
- 파드에게 부여될 워크로드의 타입에 따라 적절한 컨트롤러를 선택해야 됨
#### 워크로드 타입
- **Front-End 워크로드**: 사용자(클라이언트)의 요청을 직접 처리하는 서비스를 실행하는 역할
- **Back-End 워크로드**: 데이저 저장, 비즈니스 로직 처리, 메시징 시스템, 마이크로 서비스, 배치처리 등 서버 내부에서 동작하는 서비스를 실행하는 역할

### Deplyment(디플로이먼트)
: 어플리케이션 업데이트 및 배포를 위한 컨트롤러
- 여러 개의 파드로 수평한 클러스터를 구성할 때 사용. 가동 중인 파드를 차례대로 교체하거나 규모를 조절할 수 있는 기능을 제어하는 컨트롤러
- 새로운 버전의 어플리케이션을 서비스 중단 및 오류 없이 배포가 가능함
- 디플로이먼트는 리플리카셋을 관리하는데, label과 selector를 통해 pod 객체를 확인함
![Pasted image 20250218161653](images/Pasted%20image%2020250218161653.png)
### StatefulSet(스테이트 풀셋)
: 파드와 퍼시스턴컨트롤러
- 볼륨에 번호를 매겨 관리함
### Job(잡)
: 배치 처리하는 컨테이너가 정상 종료할 때까지 재 실행을 반복하는 컨트롤러
- 파드의 실행 횟수, 동시 실행개수, 실행 횟수 상한값을 **설정**하고 파드 삭제 전까지 **로그**를 보존
### CronJob(크론잡)
: 지정한 시간에 정기적으로 잡을 생성하는 컨트롤러
- Crontab과 같은 형식으로 잡의 생성 시작을 설정할 수 있음
`crontab`: 리눅스/유닉스 시스템에서 특정 시간 간격으로 명령어나 스크립트를 자동 실행하는 스케줄러
- 대량 메일 발송(병렬처리로 한 번에), 미디어 파일 변환처리, 대량 데이터를 포함하는 KVS 데이터베이스 검색
### DaemonSet(데몬셋)
: 모든 노드(또는 특정 노드)에서 동일한 Pod가 실행되게 하기 위해 동작하는 컨트롤러
- 새로운 노드가 추가되면 자동으로 해당 Pod를 배포해줌 
- 노드가 삭제되면 해당 Pod도 함께 삭제됨
### ReplicaSet(리플리카셋)
: Deployment와 연동되어 가동되어야 하는 파드의 수를 관리하는 컨트롤러
- 직접 설정하지 않고, Delopment를 활용하여 디플로이먼트가 리플리카셋을 관리함
- **ReplicationController**의 개선된 버전
- RC → RS → Deployment 순으로 발전됨

#### 정리
![Pasted image 20250217231139](images/Pasted%20image%2020250217231139.png)
## K8s 구성요소 마무리
- K8s 클러스터는 Master 노드와 Worker 노드로 구분된다.(근데 미니쿠베에서는 합쳐져 있음)
- 마스터 노드는 목표 상태가 기술된 manifest를 실행하고 상태가 유지되도록 오브젝트를 제어함
- 워커 노드는 실제 어플리케이션이 실행되는 일반 노드로, 마스터 노드의 지시에 따라 컨테이너(or 파드)를 실행함
- K8s 클러스터의 모든 조작은 API에 의해 동작함
- 주요 오브젝트로는 Pod, Service, Controller가 있음
- Pod는 컨테이너의 기동 단위로, 서비스와 컨트롤러와 함께 사용됨
- Service는 클라이언트의 요청을 지정한 파드에 로드밸런싱 하여 전송하는 역할을 수행함
- Controller는 워크로드의 특성에 맞춰, 맞는 컨트롤러를 선택하여 사용함
- Delopyment 컨트롤러는 웹 서버나 API 서버처럼 지속적으로 서비스를 제공해야하는 워크로드에 적합함
- Job 컨트롤러는 *배치 처리*와 같은 워크로드에 적합함
	*배치처리*: 일정한 데이터를 모아서 한 번에 처리하는 방식(특정 시점이나 특정 조건에)

# 5. 파드와 컨트롤러의 관계
![Pasted image 20250218154931](images/Pasted%20image%2020250218154931.png)

# 6. Pod의 헬스체크 기능(Probe)
`Probe`: `kubelet`에서 컨테이너의 상태를 검사하는 매커니즘
=> 기존 로드밸런서와 달리 

- `활성 프로브`(Liveness Probe) : 컨테이너가 **정상**적으로 실행 중인지 **확인**하고 문제가 생기면 **자동으로 복구**하는 기능
	- 프로브 검사에 실패하당 해당 컨테이너는 강제 종료되고 쿠버네티스는 자동으로 재시작
	- 활성 프로브를 설정하지 않으면, 어플리케이션이 응답하지 않더라도 컨테이너가 계속 유지될 수 있음
- `준비 상태 프로브`(Readiness Probe) : **컨테이너** 내부 어플리케이션이 트래픽을 받을 **준비**가 되었는지 **확인**하는 기능
	- 검사에 실패하면 해당 Pod를 로드밸런서에서 제외하여, 서비스에서 트래픽을 못보내게 함
	- 어플리케이션이 초기화 되는게 시간이 걸릴 경우에 유용

# 7. 사이드카 패턴
=> 하나의 Pod 안에서 보조 컨테이너를 함께 실행하는 설계 방식
- ex) 웹 서버 컨테이너(**메인**)와 최신 콘텐츠를 깃헙에서 다운받는 컨테니어(**보조**)의 조합
- 어플리케이션 변경 없이, 사이드카를 붙였다 떼거나 교체하기가 쉬운 구성방식임
- 메인과 사이드카(보조) 컨테이너가 같은 Pod 안에 있기 때문에 리소스를 적절히 설정하여, 서로 간의 **의존성 관리**가 **필요**함

# 8. Delopyment의 버전 변경 전략
1) 재생성 전략(`Recreate`)
	- 디플로이먼트와 관련된 모든 포드를 중지하고, 새로운 버전의 포드를 생성하는 전략
	- **빠르고 간편**하지만, 서비스 **다운타임**이 **발생**
	- 다운타임이 허용되는 테스트 배포에 적합
2) 롤링업데이트 전략(`RollingUpdate`)
	- 모든 Pod를 한 번에 업데이트 하는게 아닌, 일정 수로 나누어 업데이트 하는 방식의 전략
	- 다운타임 X
	- recreate 전략보다 느리지만, 정교하고 **안정적**
	- 업데이트 중에 버전 차이로 인한 서비스 중단이 발생하지 않도록 해야됨

```
💡 클라우드에서 롤링업데이트
ALB(Application LoadBanlancer)에서 무중단 배포를 지원하기 위해, 업데이트를 할 때는 EC2를 새로 만들어서 세팅을 함. 원래 운영이 되던 EC2는 사용자가 없어지게 되면 없앰.
```

# 9. Ingress(인그레스)
:  클러스터 외부에서 내부 서비스로 들어오는 HTTP/HTTPS 트래픽을 라우팅하는 리소스
- 하나의 설정으로 여러 도메인의 트래픽을 각가 다른 서비스로 라우팅할 수 있음(가상 호스트가 가능)
- 클라이언트 요청을 여러 파드에 분산해줌
- SSL/TLS 암호화 통신 HTTPS 프로토콜 지원
- `Session Affinity` 지원
- 기존 로드밸런서를 대체 가능
- 어플리케이션 URL을 통해 매핑


# 한 줄 정리

|                       | 정의                                                                                                        | 비고                                                                                                                         |
| --------------------- | --------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------- |
| **kubectl**           | 커맨드라인 인터페이스로, 쿠버네티스 클러스터를 조작하기 위한 도구이다.                                                                   |                                                                                                                            |
| **kube-scheduler**    | 쿠버네티스의 기본 스케줄러로, 파드를 실행 가능한 노드를 찾은 다음, 점수를 계산하여 가장 점수가 높은 노드를 선택한다.                                       |                                                                                                                            |
| **kube-apiserver**    | 클러스터의 모든 요청을 처리하는 중앙 API 게이트웨이로, 클라이언트로부터 오는 REST 요청을 검증하고 API 오브젝트를 구성하고 상태를 보고한다.                       |                                                                                                                            |
| **etcd**              | 쿠버네티스 클러스터의 모든 관리 데이터가 저장되는 곳이다.                                                                          | JSON 기반으로 Key-Value 형태로 저장                                                                                                 |
| **kube-controller**   | 쿠버네티스 클러스터에서 실행되는 여러 개의 컨트롤러를 통합 관리하는 프로세스                                                                |                                                                                                                            |
| **kube-proxy**        | 네트워크 라우팅 및 로드밸런싱을 담당하는 프록시이다.                                                                             | 클러스터 내부에서 Pod 간의 트래픽을 라우팅                                                                                                  |
| **kubelet**           | 각 노드에서 실행되는 에이전트 프로세스로, 해당 노드에서 실행되는 파드와 컨테이너를 관리한다.                                                      | 파드와 컨테이너 실행  <br>파드와 노드 상태를 API 서버에 보고  <br>컨테이너의 동작을 확인하는 프로브 실행  <br>내장된 cAdvisor를 통해 매트릭 수집 및 공개                        |
| **워크로드**              | 컨테이너, 파드, 컨트롤러의 그룹을 의미한다.                                                                                 |                                                                                                                            |
| **컨테이너**              | 쿠버네티스에서 어플리케이션이 실행되는 가장 작은 단위로, Pod 내부에서 실행되는 실행 환경이다.                                                    |                                                                                                                            |
| **파드**                | 컨테이너를 실행하기 위한 오브젝트로, 하나 이상의 컨테이너를 포함한다.                                                                   | 쿠버네티스의 기본 배포 단위                                                                                                            |
| **컨트롤러**              | 쿠버네티스에서 원하는 상태(Desired State)와 실제 상태를 자동으로 일치시키는 역할을 하는 컴포넌트이다.                                           |                                                                                                                            |
| **설정(Configuration)** | 어플리케이션이 원하는 동작하도록 환경을 정의하는 것을 말한다.                                                                        | docker-compose 처럼                                                                                                          |
| **서비스**               | 클러스터 내 Pod 간 또는 외부에서 Pod로의 트래픽을 안정적으로 연결하는 네트워크 엔드포인트이다.                                                  |                                                                                                                            |
| **스토리지**              | 컨테이너의 데이터 유지를 위한 볼륨 및 영구 저장소이다.                                                                           | 파드는 휘발성이기 때문                                                                                                               |
| **매니페스트**             | 쿠버네티스 리소스를 정의하는 설정 파일                                                                                     | YAML 또는 JSON 형식의 파일을 사용                                                                                                    |
| **클러스터 네트워크**         | Pod 간 통신을 가능하게 하는 네트워크 구조이다.                                                                              | CNI(Container Network Interface)를 통해 구현된다.  <br>Flannel, Calico                                                            |
| **Flannel**           | 가장 기본적인 Kubernetes CNI 플러그인으로, 오버레이 네트워크를 사용하여 Pod 간 통신을 지원한다.                                            | 네트워크 정책 미지원  <br>작은 규모에서 주로 사용                                                                                             |
| **Calico**            | BGP(Border Gateway Protocol) 기반으로 동작하는 CNI 플러그인으로, 고성능 네트워킹과 네트워크 정책 지원이 가능하다.                            | 대규모 클러스터에서 사용                                                                                                              |
| **디플로이먼트**            | 여러 개의 파드로 수평한 클러스터를 구성, 사용자가 원하는 개수만큼 파드를 생성하고, 업데이트 및 복구를 자동으로 처리할 수 있게 해줌(파드를 새로운 버전으로 업데이트 해주는 컨트롤러이다) | 가동 중인 파드를 차례대로 교체하거나, 파드 개수를 조절할 수 있는 기능이 있음  <br>장점: 자동 복구, 무중단 롤링 업데이트 지원, 롤백 가능 등 데이터 저장이 필요 없고, 빠르게 배포해야 하는 어플리케이션에 적합 |
| **스테이트 풀셋**           | Pod와 Persistent Volume(영구 스토리지)를 조합하여, 데이터 보관에 초점을 둔 컨트롤러이다.                                              | 볼륨에 번호를 매겨 관리  <br>stateless한 디플로이먼트와 다르게, 특정 파드가 삭제되더라도 데이터와 식별정보가 유지됨                                                    |
| **잡**                 | 배치처리를 하는 컨테이너가 정상 종료할 때까지 재실행을 반복하는 컨트롤러이다.                                                               | 파드의 실행 횟수, 동시 실행개수, 실행 횟수 상한값을 **설정**하고 파드 삭제 전까지 **로그**를 보존                                                               |
| **크론잡**               | 정해진 일정에 따라 반복되는 Job 컨트롤러이다.                                                                               |                                                                                                                            |
| **데몬셋**               | 모든 노드(또는 특정 노드)에서 동일한 Pod가 실행되게 하기 위해 동작하는 컨트롤러이다.                                                        | 새로운 노드가 추가되면 자동으로 Pod를 배포해줌  <br>노드가 삭제되면 해당 Pod도 함께 삭제됨                                                                   |
| **리플리카셋**             | Deployment와 연동되어 가동되어야 하는 파드의 수를 관리하는 컨트롤러이다.                                                             |                                                                                                                            |
| **사이드카 패턴**           | 하나의 Pod 안에서 보조 컨테이너를 함께 실행하는 설계 방식이다.                                                                     | 기능을 분리하여 확장성을 높이고 관리성을 개성하는 패턴  <br>보조 컨테이너가 주 컨테이너에 영향을 미치지 않게 설계해야 됨                                                     |
| **인그레스**              | 클러스터 외부에서 내부 서비스로의 HTTP/HTTPS 트래픽을 관리하는 Kubernetes 리소스이다.                                                 | 외부에서 클러스터 내부로 트래픽 라우팅(로드밸런싱)                                                                                               |
| **HPA**               | CPU, 메모리 사용량을 기준으로 자동으로 Pod 개수를 조정하는 오토스케일링 기능이다.                                                         |                                                                                                                            |
|                       |                                                                                                           |                                                                                                                            |
